* Fossicker
** Implementation
- Project specification order should drive type dispatch precedence, not the type dispatcher list.
- Dispatcher can be a _function_ or a _list_ of regular expressions. dispatch-p should run the fn with input or run regexp-scan on list items.
- asset-dispatcher doesn't have much value as an object. Make-instance doesn't really fit to API when automatically pushed to *type-registry*. Maybe it should be the old way, except match-p is a generic fn and dispatches on list and function classes. create-asset-dispatcher?
- Namestring is generally a better description of user input that I usually refere as fname.
- Maybe use class instead of type?
- *dispatch-table* is better instead of type registry. Types aren't there anymore.
- legend is part of project. config will define default legend, a project can define its own legend. if defined, it will not append to default, it will completely override it, because it is not possible to remove effective duplicates properly in case of regexp entries.
- UI: Generate, Project, History, Settings
- Everytime user inputs a successive namestring, a new asset will be generated and set as current. But only when the user hits export, the asset will be exported and recorded to project history, assuming export op returned success.
- User will be able to select another asset from history. If it is an instance of a subclass of asset, user will be able to export, or delete it. If it is an instance of asset, user will be able to regenerate, or delete.
- Regenerate will generate an asset using the namestring, source (if exists), and context. Then it will set the new asset as current.
- Write project history to seperate file? so it can be ignored from project? VC.
- Any asset read from histroy is just an asset, not an instance of a specific asset class. Because type specifications will change between sessions.
- Asset class will provide delete/regenerate function for their history assets.
- If deleted it is deleted from history.
- Recovery requires keeping track of changes in project folder because it is ambiguous what the user intends to do if they manually edited files. Keeping track of changes in actual files is the job of a VC system. Warn before deletion though.
- Defining a plugin-loader method that specialize on plugin name is great. This is influenced from Xach's output method approach on Reddit plugin question.
- Everything that is explicitly referenced by the application should be defined in application namespace or a predefined alternative namespace. This saves application programmer from doing namespace fiddling and plugin writer from having to define a predetermined namespace.
** Interface
- There will be three methods of communication with fossicker: GUI, CLI and server.
- There will be two essential query methods plugins will need:
  - string input prompt.
  - selection prompt with options.
- An abstraction for those two methods should be provided so the plugin can prompt without knowing how it is interacting with the user.
- For Slime and CLI, standard error handling is good, but for GUI, errors should be handled with a proper method.
- If no parameter is provided on startup, or -gui parameter is explicitly provided, and if there is an active desktop session, fossicker will start in GUI mode. If it was explicitly started with -cli parameter or there is no desktop session available, it will start in command line, the CLI session will be managed by one character mode settings like fdisk.
- If -srv is provided, the swank server will start so emacs or other clients can connect it.
** Export
- Export objects will hold an MD5 sum of the files generated. It will warn twice if the mp5sum of the file being deleted is different thant the one recorded because that means user edited/overwrote the wile after creation. Date created of the file might as well be used but it is much less reliable.
- The creation date of an export is seperate than the creation date of an asset?
- Export:
  - :path :: pathname
  - :date :: date => ?
  - :md5sum ::
- If md5sum is nil, it probably means there already was a file during export and user has chosen not to overwrite it.
- Export class can be subclassed by and used by the asset subclasses for instances of export data for convenience. But only the slots related to export class will be saved to history. What happens if the subclass shadows export slots is undefined. Just as with asset types.
- An export can be browsed using webbrowser because it knows how to handle most data types.

